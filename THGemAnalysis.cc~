#include <iostream>
#include <fstream>
#include <string>
#include <ctime>
#include <vector>
#include <dirent.h>
#include <math.h>

#include <TROOT.h>
#include <TApplication.h>
#include <TMath.h>
#include <TH1F.h>
#include <TH1I.h>
#include <TCanvas.h>
#include <TFile.h>

#include "Garfield/ComponentAnsys123.hh"
#include "Garfield/MediumMagboltz.hh"
#include "Garfield/ViewMedium.hh"
#include "Garfield/ViewSignal.hh"
#include "Garfield/ViewFEMesh.hh"
#include "Garfield/Sensor.hh"
#include "Garfield/AvalancheMicroscopic.hh"
#include "Garfield/AvalancheMC.hh"
#include "Garfield/Random.hh"
#include "Garfield/TrackHeed.hh"
#include "Garfield/Plotting.hh"

using namespace Garfield;

std::string rootname = "result_hists.root";
TFile *f = new TFile(rootname.c_str(), "RECREATE");

void ReadTXTMuon()
{
  std::string line;
  double nsum, esum;

  std::ifstream File;
  File.open("muon.txt");
  std::vector<double> NSum, ESum;

  getline(File, line);

  if (line[0] != '#' && line.length() != 0)
  { // Ignore info
    size_t stop1 = line.find(";");
    size_t stop2 = line.find(";", stop1 + 1);
    nsum = stod(line.substr(0, stop1));
    esum = stod(line.substr(stop1 + 1, stop2));
    NSum.push_back(nsum);
    ESum.push_back(esum * 1.E-3);

    // Histograms
    TH1F *hNSum = new TH1F("hEne", "No of primary electrons", 100, 0, 200);
    TH1F *hESum = new TH1F("hEle", "Energy loss", 100, 0, 200);

    // std::cout << "\n\nFilling histograms  " << std::endl;
    for (int i = 0; i < 100; i++)
    {
      hNSum->Fill(NSum[i]);
      hESum->Fill(ESum[i]);
    }

    std::cout << "\n\nFilled histograms  " << std::endl;
    hNSum->Write();
    hESum->Write();
    std::cout << "Saved histograms  " << std::endl;
  }
}

void ReadTXTPositionResolution()
{
  // TFile *f = new TFile(rootname.c_str(), "UPDATE");

  std::string line;
  int ne;

  std::ifstream File;
  File.open("resolution.txt");
  std::vector<double> PosX;
  std::vector<double> PosY;
  double px, py;

  getline(File, line);

  if (line[0] != '#' && line[0] != 'n' && line.length() != 0)
  { // Ignore info
    size_t stop1 = line.find(";");
    size_t stop2 = line.find(";", stop1 + 1);
    px = stod(line.substr(0, stop1));
    py = stod(line.substr(stop1 + 1, stop2));
    ;
    PosX.push_back(px);
    PosY.push_back(py);
  }

  // Histograms
  int nBins = 100;
  float hmin = *min_element(PosX.begin(), PosX.end()) / 7;
  float hmaxN = *max_element(PosX.begin(), PosX.end()) / 7;
  std::string name_rx = "hPosX_";
  std::string name_ry = "hPosY_";

  TH1I *hpx = new TH1I(name_rx.c_str(), "", nBins, hmin, hmaxN);
  TH1I *hpy = new TH1I(name_ry.c_str(), "", nBins, hmin, hmaxN);

  for (int i = 0; i < 5; i++)
  {
    hpx->Fill(PosX[i]);
    hpy->Fill(PosY[i]);
  }

  std::cout << "\n\nFilled histograms for " << std::endl;
  hpx->Write();
  hpy->Write();
  std::cout << "Saved histograms for " << std::endl;

  double m1x, m2x, s1x, s2x;
  double m1y, m2y, s1y, s2y;

  int bin1x = hpx->FindFirstBinAbove(hpx->GetMaximum() / 2);
  int bin2x = hpx->FindLastBinAbove(hpx->GetMaximum() / 2);
  m2x = hpx->GetBinCenter(bin2x) - hpx->GetBinCenter(bin1x);

  m1x = (hmaxN - hmin) / nBins * 1e4;
  s2x = m1x / sqrt(12);

  int bin1y = hpy->FindFirstBinAbove(hpy->GetMaximum() / 2);
  int bin2y = hpy->FindLastBinAbove(hpy->GetMaximum() / 2);
  m2y = hpy->GetBinCenter(bin2y) - hpy->GetBinCenter(bin1y);

  m1y = (hmaxN - hmin) / nBins * 1e4;
  s2y = m1y / sqrt(12);

  std::cout << "Pad Size: " << m1x << std::endl;
  std::cout << "Position Resolution X: " << m2x * 1e4 << "(" << s2x << ")" << std::endl;
  std::cout << "Position Resolution Y: " << m2y * 1e4 << "(" << s2y << ")" << std::endl;
  std::cout << "Number of Entries: " << hpx->GetEntries() << std::endl;
}

void ReadTXTGain(bool draw = 0)
{
  std::string line;
  double rg, eg;
  double t;

  std::ifstream File;
  File.open("gain.txt");
  std::vector<double> RGain, EGain;
  std::vector<double> time;

  getline(File, line);

  if (line[0] != '#' && line.length() != 0)
  { // Ignore info
    size_t stop1 = line.find(";");
    size_t stop2 = line.find(";", stop1 + 1);
    rg = stod(line.substr(0, stop1));
    eg = stod(line.substr(stop1 + 1, stop2));
    t = stod(line.substr(stop2 + 1, line.size()));
    RGain.push_back(rg);
    EGain.push_back(eg);
    time.push_back(t);
  }
  // }

  // Histograms
  int nBins = 100;
  float hmin = 0.;
  float hmaxR = 1.1 * *max_element(RGain.begin(), RGain.end());
  float hmaxE = 1.1 * *max_element(EGain.begin(), EGain.end());
  float hmaxT = 1.1 * *max_element(time.begin(), time.end());
  std::string name_r = "hRGain_";
  std::string name_e = "hEGain_";

  TH1F *hRGain = new TH1F(name_r.c_str(), "Real Gain", nBins, hmin, hmaxR);
  TH1F *hEGain = new TH1F(name_e.c_str(), "Effective Gain", nBins, hmin, hmaxE);
  TH1F *hT = new TH1F("Time", "Time", nBins, hmin, hmaxT);

  for (int i = 0; i < 5; i++)
  {
    if (EGain[i] > 0)
    {
      hRGain->Fill(RGain[i]);
      hEGain->Fill(EGain[i]);
      hT->Fill(time[i]);
    }
  }

  std::cout << "\n\nFilled histograms  " << std::endl;
  hRGain->Write();
  hEGain->Write();
  std::cout << "Saved histograms  " << std::endl;

  if (draw == 1)
  {
    TCanvas *c1 = new TCanvas("", "canvas");
    c1->Divide(1, 2);
    c1->cd(1);
    hRGain->Draw();
    c1->cd(2);
    hEGain->Draw();
    std::string image = name_r + ".pdf";
    c1->SaveAs(image.c_str());
  }

  double m1, m2, s1, s2;
  m1 = hRGain->GetMean();
  m2 = hEGain->GetMean();
  s1 = hRGain->GetStdDev() / sqrt(hRGain->GetEntries());
  s2 = hEGain->GetStdDev() / sqrt(hEGain->GetEntries());
  std::cout << "Real Gain: " << m1 << "(" << s1 << ")" << std::endl;
  std::cout << "Effective Gain: " << m2 << "(" << s2 << ")" << std::endl;
  std::cout << "Number of Entries: " << hRGain->GetEntries() << std::endl;
  std::cout << "Average time: " << hT->GetMean() << std::endl;

  f->Close();
  std::cout << "\nFinished saving all histograms!\n"
            << std::endl;
}


int main(int argc, char *argv[])
{

  // Temperature (temp) in Kelvin and Pressure (press) in Torr
  double percent = 70.;
  double ppm = 0.;
  double penning = 0.57;
  const char *noble = "ar";
  double temp = 293.15;
  double press = 760;
  // Import

  ComponentAnsys123 *fm = new ComponentAnsys123();
  fm->Initialise("ELIST.lis",
                 "NLIST.lis",
                 "MPLIST.lis",
                 "PRNSOL.lis", "mm");
  fm->SetWeightingField("PRNSOL.lis", "WT");
  fm->EnableMirrorPeriodicityX();
  fm->EnableMirrorPeriodicityY();
  fm->PrintRange();

  double co2 = 100. - percent;
  double ar = percent;

  // Medium
  MediumMagboltz *gas = new MediumMagboltz();
  gas->LoadGasFile("ar_70_co2_30.gas");
  // gas->LoadGasFile("ar_90_co2_10.gas");
  // gas->LoadGasFile("ar_80_co2_20.gas");

  // gas->LoadGasFile("xe-100.gas");

  gas->EnableDrift();
  gas->SetMaxElectronEnergy(18000);
  gas->Initialise();

  if (penning != 0.)
  {
    gas->EnablePenningTransfer(penning, 0., noble);
  }
  else
  {
    gas->DisablePenningTransfer();
  }

  gas->LoadIonMobility("IonMobility_Ar+_Ar.txt");
  int nMaterials = fm->GetNumberOfMaterials();
  for (int i = 0; i < nMaterials; ++i)
  {
    const double eps = fm->GetPermittivity(i);
    if (fabs(eps - 1.) < 1.e-3)
      fm->SetMedium(i, gas);
  }

  fm->PrintMaterials();

  std::string txtfileG = "gain.txt";
  std::string txtfileM = "muon.txt";
  std::string txtfileR = "resolution.txt";
  double zmax =0.3;
  double zmin = -0.1;
  double driftzone = 0.0001;
  int n_events = 5;

  // Time
  const double t0 = 0., tEnd = 1.E3;
  const int nTimeBins = 100;

  // Sensor
  Sensor *sensor = new Sensor();
  sensor->AddComponent(fm);
  sensor->SetArea(-10, -10, zmin, 10, 10, zmax);
  sensor->AddElectrode(fm, "WT");
  sensor->SetTimeWindow(t0, (tEnd - t0) / nTimeBins, nTimeBins);

  // Drift Visualization
  ViewDrift *vDrift = new ViewDrift();
  vDrift->SetArea(-0.5, -0.5, zmin, 0.5, 0.5, zmax);

  // Avalanche Setup
  AvalancheMicroscopic *aval = new AvalancheMicroscopic();
  aval->SetSensor(sensor);
  aval->EnableSignalCalculation();
  aval->SetCollisionSteps(100);
  aval->EnableAvalancheSizeLimit(18000);
  aval->EnablePlotting(vDrift);

  AvalancheMC *drift = new AvalancheMC();
  drift->SetSensor(sensor);
  drift->SetDistanceSteps(2.e-4);
  drift->EnableRKFSteps(true);
  drift->EnablePlotting(vDrift);

  // Muon Track Setup
  TrackHeed *track = new TrackHeed();
  track->SetSensor(sensor);
  track->SetParticle("mu-"); // muon-
  track->SetEnergy(4E9);     // GeV
  track->EnableElectricField();
  track->EnablePlotting(vDrift);

  // File
  FILE *file;
  const char *f_titleG = txtfileG.c_str();
  const char *f_titleM = txtfileM.c_str();
  const char *f_titleR = txtfileR.c_str();

  // Avalanches Calculations
  for (int i = n_events; i--;)
  {
    clock_t begin_time = clock();

    // Random Initial Positions
    double z0 = zmax - driftzone;
    std::cout << "Z0: " << z0 << std::endl;
    // double x0 = (2 * RndmUniform() - 1) / 2;
    // double y0 = (2 * RndmUniform() - 1) / 2;
    double x0 = 0.5 * (RndmUniform() - 1);
    double y0 = 0.5 * (RndmUniform() - 1);
    const double t0 = 0.;
    // Velocity vector (direction only)
    const double dx0 = 0.;
    const double dy0 = 0.;
    const double dz0 = -1;

    track->NewTrack(x0, y0, z0, t0, dx0, dy0, dz0);

    double xc, yc, zc, tc, extra;
    int nc = 0, nsum = 0.;
    double ec = 0., esum = 0.;
    while (track->GetCluster(xc, yc, zc, tc, nc, ec, extra))
    {
      esum += ec;
      nsum += nc;

      for (int j = 0; j < nc; j++)
      {

        // Properties of primary electron (pos, time, energy, velocity vector)
        double xe1, ye1, ze1, te1, e1, dxe, dye, dze;
        track->GetElectron(j, xe1, ye1, ze1, te1, e1, dxe, dye, dze);

        aval->AvalancheElectron(x0, y0, z0, te1, 0., 0., 0., 0.);

        int ne = 0, ni = 0, nf = 0;
        double sumy = 0, sumx = 0;
        // aval->GetAvalancheSize(ne, ni);
        int np = aval->GetNumberOfElectronEndpoints();
        np += ne;

        // Final Positions Analysis
        // Start of track
        double xe2, ye2, ze2, te2, e2;
        // End of track
        double xe3, ye3, ze3, te3, e3;
        int status;

        for (int j = np; j--;)
        {
          aval->GetElectronEndpoint(j, xe2, ye2, ze2, te2, e2,
                                    xe3, ye3, ze3, te3, e3, status);

          if (ze3 <= zmin + 0.0001)
          { // Added a delta to minimize border effects
            nf += 1;

            sumx += xe3;
            sumy += ye3;
          }
        }

        // Integrate current to get total charge on pad
        double sum = 0.;
        for (int k = 0; k < nTimeBins; k++)
        {
          double wt = -1 * sensor->GetSignal("WT", k) / ElementaryCharge;
          sum += wt;
        }
        // std::cout << "Integrated Signal Final" << sum << std::endl;

        // Saving Gains
        float min = float(clock() - begin_time) / (CLOCKS_PER_SEC * 60);
        file = fopen(f_titleG, "a");
        fprintf(file, "%d;%d;%f\n", np, abs(nf), min);
        fclose(file);

        std::cout << "Gain saved" << std::endl;

        file = fopen(f_titleM, "a");
        fprintf(file, "%d;%f\n", nsum, esum);
        fclose(file);

        std::cout << "Muon saved" << std::endl;

        file = fopen(f_titleR, "a");
        fprintf(file, "%f;%f\n", abs(sumx / nf), abs(sumy / nf));
        fclose(file);

        std::cout << "position resolution saved" << std::endl;

        // std::cout << i << "/" << n_events << std::endl;
        // std::cout << "No Of Primary Electrons : " << nsum << std::endl;
        // std::cout << "Electons at Electrode : " << nf << std::endl;
        // std::cout << "gain : " << nf / nsum << std::endl;
      }
    }
  }

  // Geometry and Track Visualization
  TCanvas *c1 = new TCanvas("tr", "Track");
  ViewFEMesh *vFE = new ViewFEMesh();

  vFE->SetComponent(fm);
  vFE->SetCanvas(c1);
  vFE->SetPlane(0, -1, 0, 0, 0, 0);
  vFE->SetFillMesh(true);
  vFE->SetColor(2, kCyan - 3);
  vFE->SetColor(1, kOrange + 7);
  vFE->SetColor(0, kOrange + 7);
  vFE->EnableAxes();
  vFE->SetXaxisTitle("x (cm)");
  vFE->SetYaxisTitle("z (cm)");
  vFE->SetArea(-0.5, -0.5, zmin, 0.5, 0.5, zmax);
  vFE->SetViewDrift(vDrift);
  vFE->Plot();
  c1->SaveAs("avalanch.png");

  // View Signal
  TCanvas *c3 = new TCanvas("c", "Current");
  ViewSignal *signalView = new ViewSignal();
  signalView->SetSensor(sensor);
  signalView->SetCanvas(c3);
  signalView->PlotSignal("WT");
  c3->SaveAs("signal.png");

  ReadTXTMuon();
  ReadTXTGain();
  ReadTXTPositionResolution();
}
